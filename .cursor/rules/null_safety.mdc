---
description: Null Safety - Boas práticas para null safety no Dart
globs: ["lib/**/*.dart"]
alwaysApply: true
---

# Null Safety - Boas Práticas

## Princípios Fundamentais

### Null Safety no Dart
- ✅ Dart 2.12+ tem null safety habilitado por padrão
- ✅ Variáveis não são nullable por padrão
- ✅ Use `?` apenas quando necessário
- ✅ Evite `null` quando possível

## Declaração de Tipos

### Non-nullable por Padrão
- ✅ Variáveis são non-nullable por padrão
- ✅ Use tipos explícitos para clareza

```dart
// ✅ Bom: non-nullable por padrão
String userName = 'John';
int age = 25;
bool isActive = true;

// ❌ Não funciona: não pode ser null
String userName = null; // Error: A value of type 'Null' can't be assigned
```

### Nullable Types
- ✅ Use `?` apenas quando realmente necessário
- ✅ Documente por que uma variável pode ser null

```dart
// ✅ Bom: nullable quando necessário
String? optionalUserName;
int? optionalAge;

// ✅ Bom: nullable com documentação
/// User name. Can be null if user hasn't set a name yet.
String? userName;

// ❌ Evite: nullable desnecessário
String? userName = 'John'; // Não precisa ser nullable se sempre terá valor
```

## Inicialização

### Variáveis Locais
- ✅ Inicialize variáveis imediatamente ou use `late`
- ✅ Use `final` quando o valor não muda

```dart
// ✅ Bom: inicialização imediata
String userName = 'John';

// ✅ Bom: late para inicialização tardia
late String userName;
void init() {
  userName = 'John';
}

// ❌ Erro: variável não inicializada
String userName; // Error: 'userName' must be initialized
```

### Campos de Classe
- ✅ Inicialize campos no construtor ou use `late`
- ✅ Use `late` para inicialização tardia

```dart
// ✅ Bom: inicialização no construtor
class User {
  final String name;
  final String? email;
  
  User({required this.name, this.email});
}

// ✅ Bom: late para inicialização tardia
class User {
  late String name;
  
  void initialize(String userName) {
    name = userName;
  }
}

// ✅ Bom: nullable para valores opcionais
class User {
  final String name;
  final String? nickname; // Pode ser null
}
```

## Null Checks

### Null-aware Operators
- ✅ Use `?.` para chamadas seguras
- ✅ Use `??` para valores padrão
- ✅ Use `??=` para atribuição condicional

```dart
// ✅ Bom: null-aware operator
String? userName;
int length = userName?.length ?? 0; // Retorna 0 se userName é null

// ✅ Bom: null-coalescing operator
String displayName = userName ?? 'Anonymous';

// ✅ Bom: null-aware assignment
String? userName;
userName ??= 'Default'; // Atribui apenas se for null
```

### Null Assertion
- ✅ Use `!` apenas quando absolutamente seguro
- ✅ Evite `!` quando possível (use null checks)
- ✅ Documente por que é seguro usar `!`

```dart
// ✅ Bom: null check antes de usar
String? userName;
if (userName != null) {
  int length = userName.length; // Safe: já verificamos
}

// ⚠️ Use com cuidado: null assertion
String? userName;
int length = userName!.length; // Pode lançar exceção se null

// ✅ Melhor: usar null-aware operator
int length = userName?.length ?? 0;

// ✅ Bom: quando garantido que não é null
String getUserName() {
  final user = _currentUser!; // Garantido que não é null neste ponto
  return user.name;
}
```

## Collections Nullable

### List
- ✅ Use `List<T?>` para listas que podem conter null
- ✅ Prefira `List<T>` quando possível

```dart
// ✅ Bom: lista não-nullable
List<String> names = ['John', 'Jane'];

// ✅ Bom: lista nullable quando necessário
List<String?> names = ['John', null, 'Jane'];

// ✅ Bom: lista nullable de non-nullable
List<String>? names; // Lista pode ser null, mas elementos não são null
```

### Map
- ✅ Use `Map<K, V?>` quando valores podem ser null
- ✅ Trate nulls ao acessar mapas

```dart
// ✅ Bom: valores nullable
Map<String, int?> scores = {
  'John': 100,
  'Jane': null,
};

// ✅ Bom: acesso seguro
int? score = scores['John']; // Pode ser null
int safeScore = scores['John'] ?? 0; // Valor padrão
```

## Funções e Métodos

### Parâmetros Nullable
- ✅ Use `required` para parâmetros obrigatórios
- ✅ Use `?` para parâmetros opcionais que podem ser null
- ✅ Use valores padrão quando possível

```dart
// ✅ Bom: parâmetro obrigatório
void createUser(String name) { }

// ✅ Bom: parâmetro opcional nullable
void createUser(String name, {String? email}) { }

// ✅ Bom: valor padrão (preferível sobre nullable)
void createUser(String name, {String email = ''}) { }

// ✅ Bom: required para nullable quando necessário
void createUser({
  required String name,
  String? email, // Opcional e pode ser null
}) { }
```

### Retorno Nullable
- ✅ Retorne `T?` quando o resultado pode ser null
- ✅ Documente quando null pode ser retornado

```dart
// ✅ Bom: retorno nullable quando necessário
String? findUser(String id) {
  // Retorna null se não encontrar
  return _users[id];
}

// ✅ Bom: retorno non-nullable quando sempre tem valor
String getUserName() {
  return _currentUser.name; // Garantido que não é null
}

// ✅ Bom: documentação
/// Finds a user by ID. Returns null if user not found.
User? findUser(String id) {
  return _users[id];
}
```

## Null Safety com Generics

### Generic Types
- ✅ Use `T?` para tipos genéricos nullable
- ✅ Use `T` para tipos genéricos non-nullable

```dart
// ✅ Bom: generic non-nullable
class Repository<T> {
  Future<T> findById(String id) async { /* ... */ }
}

// ✅ Bom: generic nullable
class Repository<T> {
  Future<T?> findById(String id) async { /* ... */ }
}

// ✅ Bom: uso
final userRepo = Repository<User>();
final user = await userRepo.findById('123'); // User?
```

## Null Safety em APIs

### APIs Externas
- ✅ Trate nulls de APIs externas
- ✅ Valide dados antes de usar
- ✅ Use mappers para converter nulls

```dart
// ✅ Bom: tratamento de nulls de API
class UserModel {
  final String? name;
  final String? email;
  
  UserModel({this.name, this.email});
  
  User toEntity() {
    return User(
      name: name ?? 'Unknown',
      email: email ?? '',
    );
  }
}
```

### JSON Parsing
- ✅ Trate nulls ao fazer parse de JSON
- ✅ Use valores padrão quando necessário

```dart
// ✅ Bom: parse seguro de JSON
UserModel.fromJson(Map<String, dynamic> json)
    : name = json['name'] as String?,
      email = json['email'] as String?;

// ✅ Bom: com valores padrão
UserModel.fromJson(Map<String, dynamic> json)
    : name = json['name'] as String? ?? 'Unknown',
      email = json['email'] as String? ?? '';
```

## Boas Práticas

### Evitar Null
- ✅ Prefira valores padrão sobre null
- ✅ Use enums para estados ao invés de null
- ✅ Use Optional types quando apropriado

```dart
// ✅ Bom: valor padrão
String getUserName() => _userName ?? 'Anonymous';

// ✅ Bom: enum ao invés de null
enum UserStatus { active, inactive, pending }

// ✅ Bom: Optional type
class Optional<T> {
  final T? _value;
  Optional(this._value);
  bool get isPresent => _value != null;
  T get value => _value!;
}
```

### Validação
- ✅ Valide nulls antes de usar
- ✅ Use asserts em desenvolvimento
- ✅ Trate nulls graciosamente

```dart
// ✅ Bom: validação
String getUserName() {
  if (_userName == null) {
    throw StateError('User name not set');
  }
  return _userName!;
}

// ✅ Bom: validação com assert
String getUserName() {
  assert(_userName != null, 'User name must be set');
  return _userName!;
}

// ✅ Bom: tratamento gracioso
String getUserName() => _userName ?? 'Anonymous';
```

### Documentação
- ✅ Documente quando nulls são esperados
- ✅ Explique por que uma variável é nullable
- ✅ Documente quando null pode ser retornado

```dart
/// User service for managing user operations.
class UserService {
  /// Current user. Can be null if no user is logged in.
  User? _currentUser;
  
  /// Gets the current user. Returns null if no user is logged in.
  User? getCurrentUser() {
    return _currentUser;
  }
}
```

## Checklist

- [ ] Variáveis são non-nullable por padrão
- [ ] Nullable (`?`) é usado apenas quando necessário
- [ ] Variáveis são inicializadas ou marcadas como `late`
- [ ] Null checks são feitos antes de usar valores nullable
- [ ] Null-aware operators (`?.`, `??`) são usados quando apropriado
- [ ] `!` é usado apenas quando absolutamente seguro
- [ ] Funções retornam `T?` quando null é possível
- [ ] Parâmetros nullable são documentados
- [ ] APIs externas tratam nulls adequadamente
